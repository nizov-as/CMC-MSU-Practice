-- 1. ОСНОВЫ РЕЛЯЦИОННОЙ МОДЕЛИ И SQL
/*  */


--------------------------
-- 1.1 Отношение (таблица)
--------------------------


---------------------
-- 1.2 Выборка данных
---------------------

/* IF(логическое_выражение, выражение_1, выражение_2). Если истина, в поле заносится выражение_1, если ложь — выражение_2. */

/* Если количество книг меньше 4 – то скидка 50%, меньше 11 – 30%, в остальных случаях – 10%. И еще укажем какая именно скидка на каждую книгу. */
SELECT title, amount, price,
    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,
    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка
FROM book;

/* Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту). */
SELECT author, title
FROM book
WHERE amount BETWEEN 2 AND 14
ORDER BY author DESC, title;

/* Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. 
% — Любая строка, содержащая ноль или более символов
_ — Любой одиночный символ */

/* Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания. */
SELECT title FROM book 
WHERE  title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */


----------------------------------
-- 1.3 Запросы, групповые операции
----------------------------------

/* Отобрать различные (уникальные) элементы столбца amount таблицы book. */
SELECT DISTINCT 
    amount 
FROM book;

/* Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно. */
SELECT
    author AS Автор
    ,COUNT(DISTINCT title) AS Различных_книг
    ,SUM(amount) AS Количество_экземпляров
FROM book
GROUP BY author;

/* Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно. */
SELECT
    author
    ,MIN(price) AS Минимальная_цена
    ,MAX(price) AS Максимальная_цена
    ,AVG(price) AS Средняя_цена
FROM book
GROUP BY author;

/* Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой. */
SELECT
    author
    ,ROUND(SUM(price*amount), 2) AS Стоимость
    ,ROUND(SUM(price*amount)*0.18/1.18, 2) AS НДС
    ,ROUND(SUM(price*amount)-SUM(price*amount)*0.18/1.18, 2) AS Стоимость_без_НДС
FROM book
GROUP BY author

/* Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой. */
SELECT
    ROUND(MIN(price), 2) AS Минимальная_цена
    ,ROUND(MAX(price), 2) AS Максимальная_цена
    ,ROUND(AVG(price), 2) AS Средняя_цена
FROM book;

/* Термин: "агрегатная функция" вычисляет единственное значение, обрабатывая множество строк (COUNT, SUM, AVG, MAX, MIN).
Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов),
тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций. */

/* Пример: Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены. */
SELECT
    author
    ,MIN(price) AS Минимальная_цена
    ,MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;

/* Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой. */
SELECT
    ROUND(AVG(price), 2) AS Средняя_цена
    ,ROUND(SUM(price*amount), 2) AS Стоимость
FROM book
WHERE amount BETWEEN 5 AND 14;

/* Пример: Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. */
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;

/* Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости. */
SELECT
    author
    ,SUM(price*amount) AS Стоимость
FROM book
WHERE title NOT IN ("Идиот", "Белая гвардия")
GROUP BY author
HAVING SUM(price*amount) > 5000
ORDER BY Стоимость DESC;


-------------------------
-- 1.4 Вложенные запросы
-------------------------

/* Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги. */
SELECT
    author
    ,title
    ,price
FROM book
WHERE price <= (
    SELECT
        AVG(price)
    FROM book
    )
ORDER BY price DESC;

/* Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде. */
SELECT
    author
    ,title
    ,price
FROM book
WHERE ABS(price - (SELECT MIN(price) FROM book)) <= 150
ORDER BY price;

/* Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора. */
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );

/* Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора. */
SELECT
    author
    ,title
    ,price
FROM book
WHERE price < ANY (
    SELECT
        MIN(price)
    FROM book
    GROUP BY author
    );

/* Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется. */
SELECT 
    author
    ,title
    ,amount
FROM book
WHERE amount IN (
    SELECT
        amount
    FROM book
    GROUP BY amount
    HAVING COUNT(book_id) = 1 /*неважно что мы введем внутри count()*/
    );

/* Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3, а также указать среднее значение количества экземпляров книг. */
SELECT 
    title
    ,author
    ,amount 
    ,(SELECT AVG(amount) FROM book) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) > 3;

/* Посчитать сколько и каких экземпляров книг нужно заказать поставщикам,
чтобы на складе стало одинаковое количество экземпляров каждой книги,
равное значению самого большего количества экземпляров одной книги на складе. 
Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг.
Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно. */
SELECT
    title
    ,author
    ,amount
    ,(SELECT MAX(amount) FROM book) - amount AS Заказ
FROM book
WHERE (SELECT MAX(amount) FROM book) - amount <> 0

/* ПОРЯДОК ВЫПОЛНЕНИЯ ЗАПРОСОВ */
1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY


-----------------------------------
-- 1.5 Запросы корректировки данных
-----------------------------------

/* Повторение создания таблицы */
CREATE TABLE supply (
    supply_id INT PRIMARY KEY AUTO_INCREMENT
    ,title VARCHAR(50)
    ,author VARCHAR(30)
    ,price DECIMAL(8, 2)
    ,amount INT
);

/* Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М. */
INSERT INTO book(title, author, price, amount)
SELECT title, author, price, amount FROM supply
WHERE author NOT IN ('Булгаков М.А.', 'Достоевский Ф.М.');

/* Занести из таблицы supply в таблицу book только те книги, авторов которых нет в book. */
INSERT INTO book(title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE author NOT IN (SELECT author FROM book);

/* Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы. */
UPDATE book
SET price = 0.9 * price
WHERE amount BETWEEN 5 AND 10;

/* В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%. */
UPDATE book
SET
    buy = IF(amount < buy, buy - (buy-amount), buy),
    price = IF(buy = 0, 0.9 * price, price);

/* Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2). */
UPDATE book, supply
SET book.amount = book.amount + supply.amount,
    book.price = (book.price + supply.price)/2
WHERE book.title = supply.title AND book.author = supply.author;

/* Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10. */
DELETE FROM supply
WHERE author IN (
    SELECT author
    FROM book
    GROUP BY author
    HAVING SUM(amount) > 10
);

/* Термин: "агрегатная функция" вычисляет единственное значение, обрабатывая множество строк (COUNT, SUM, AVG, MAX, MIN).
Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов),
тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций. */

/* Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое количество экземпляров 5. */
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

/* Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book. */
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

/* Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book. */
CREATE TABLE ordering AS
SELECT author, title,
    (
     SELECT ROUND(AVG(amount))
     FROM book
    ) AS amount
FROM book
WHERE amount < (SELECT ROUND(AVG(amount)) FROM book);



-------------------------------------------------
-- 1.6 Таблица "Командировки", запросы на выборку
-------------------------------------------------

/* Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last. */
SELECT
    name 
    ,city
    ,per_diem
    ,date_first
    ,date_last
FROM trip
WHERE name LIKE "%а %"
ORDER BY date_last DESC;

/* Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве. */
SELECT DISTINCT
    name
FROM trip
WHERE city = 'Москва'
ORDER BY name;

/* Для каждого города посчитать, сколько раз сотрудники в нем были. Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. */
SELECT
    city
    ,COUNT(city) AS Количество
FROM trip
GROUP BY city
ORDER BY city;

/* Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество. */
SELECT 
    city
    ,COUNT(city) AS Количество
FROM trip
GROUP BY city
ORDER BY COUNT(city) DESC
LIMIT 2;

/*
id  author          title       amount
1   Булгаков        Книга_1     5
2   Булгаков        Книга_2     2
3   Достоевский     Книга_3     8
4   Достоевский     Книга_4     13
5   Бунин           Книга_5     3

SELECT
    author
    ,SUM(amount)
    ,COUNT(amount)
FROM book
GROUP BY author

-- Группа 1:
1   Булгаков        Книга_1     5
2   Булгаков        Книга_2     2
-- Группа 2:
3   Достоевский     Книга_3     8
4   Достоевский     Книга_4     13
-- Группа 3:
5   Бунин           Книга_5     3

-- Результат:
Булгаков        7   2
Достоевский     21  2
Бунин           3   1
*/

/* WHERE работает до группировки, а HAVING — после. */

/* Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке). */
SELECT
    name
    ,city
    ,DATEDIFF(date_last, date_first)+1 AS Длительность
FROM trip
WHERE city NOT IN ('Москва', 'Санкт-Петербург')
ORDER BY Длительность DESC, city DESC

/* Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить столбцы name, city, date_first, date_last. */
SELECT
    name
    ,city
    ,date_first
    ,date_last
FROM trip
WHERE DATEDIFF(date_last, date_first) = (SELECT MIN(DATEDIFF(date_last, date_first)) FROM trip);

/* Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника. */
SELECT
    name
    ,city
    ,date_first
    ,date_last
FROM trip
WHERE MONTH(date_first) = MONTH(date_last)
ORDER BY city, name;

/* Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество. */
SELECT
    MONTHNAME(date_first) AS Месяц
    ,COUNT(date_first) AS Количество
FROM trip
GROUP BY Месяц
ORDER BY Количество DESC, Месяц;

/* Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem. Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных. */
SELECT
    name
    ,city
    ,date_first
    ,per_diem*(DATEDIFF(date_last, date_first)+1) AS Сумма
FROM trip
WHERE MONTH(date_first) IN (2, 3)
ORDER BY name, Сумма DESC

/* Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма. */
SELECT
    name
    ,SUM(per_diem*(DATEDIFF(date_last, date_first)+1)) AS Сумма
FROM trip
GROUP BY name
HAVING COUNT(name) > 3
ORDER BY Сумма DESC;

/* WHERE работает до группировки, а HAVING — после. */


-----------------------------------------------------
-- 1.7 Таблица "Нарушения ПДД", запросы корректировки
-----------------------------------------------------

/* Создать таблицу fine */
CREATE TABLE fine (
    fine_id INT PRIMARY KEY AUTO_INCREMENT
    ,name VARCHAR(30)
    ,number_plate VARCHAR(6)
    ,violation VARCHAR(50)
    ,sum_fine DECIMAL(8, 2)
    ,date_violation DATE
    ,date_payment DATE
);

/* Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine. */
UPDATE fine, traffic_violation
SET
    fine.sum_fine = IF(fine.violation = 'Превышение скорости(от 20 до 40)', 500.00, 1000.00)
WHERE fine.sum_fine IS NULL;

/* Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению. */
SELECT
    name
    ,number_plate
    ,violation
FROM fine
GROUP BY name, number_plate, violation
HAVING COUNT(*) >= 2;

/* В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей.  */
UPDATE fine, (
    SELECT
        name
        ,number_plate
        ,violation
    FROM fine
    GROUP BY name, number_plate, violation
    HAVING COUNT(*) >= 2    
    ) query_in
SET 
    fine.sum_fine = fine.sum_fine*2
WHERE fine.name = query_in.name AND fine.date_payment IS NULL;


/* Водители оплачивают свои штрафы. В таблице payment занесены даты их оплаты:
Необходимо:
1) в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
2) уменьшить начисленный штраф в таблице fine в два раза (только для тех штрафов, информация о которых занесена в таблицу payment), если оплата произведена не позднее 20 дней со дня нарушения. */
UPDATE 
    fine, payment
SET 
    fine.date_payment = payment.date_payment
    ,fine.sum_fine = IF(DATEDIFF(payment.date_payment, payment.date_violation) <= 20,
                        fine.sum_fine/2, fine.sum_fine)
WHERE
    fine.name = payment.name AND
    fine.number_plate = payment.number_plate AND
    fine.violation = payment.violation AND
    fine.date_violation = payment.date_violation AND
    fine.date_payment IS NULL;


/* Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine. */
CREATE TABLE back_payment AS
SELECT 
    name
    ,number_plate
    ,violation
    ,sum_fine
    ,date_violation
FROM fine
WHERE date_payment IS NULL;

/* Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. */
DELETE FROM fine
WHERE DATEDIFF('2020-02-01', date_violation) > 0;

/* WHERE работает до группировки, а HAVING — после. */


